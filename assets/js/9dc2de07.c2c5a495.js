"use strict";(self.webpackChunksmartask=self.webpackChunksmartask||[]).push([[661],{4376:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"System Informations/Algorithms","title":"Algorithms","description":"1.1 Integer Linear Programming (ILP)","source":"@site/docs/System Informations/Algorithms.md","sourceDirName":"System Informations","slug":"/System Informations/Algorithms","permalink":"/website/docs/System Informations/Algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Students@DETI","permalink":"/website/docs/ Students@DETI"},"next":{"title":"Architecture Diagram","permalink":"/website/docs/System Informations/Arquitetura"}}');var r=i(4848),t=i(8453);const l={sidebar_position:1},o=void 0,a={},d=[{value:"1.1 Integer Linear Programming (ILP)",id:"11-integer-linear-programming-ilp",level:2},{value:"1.2 Hill Climbing",id:"12-hill-climbing",level:2},{value:"1.3 Greedy Randomized",id:"13-greedy-randomized",level:2},{value:"1.4 Greedy Randomized with Hill Climbing Refinement",id:"14-greedy-randomized-with-hill-climbing-refinement",level:2},{value:"2.1 Genetic Algorithm",id:"21-genetic-algorithm",level:2},{value:"2.2 Constraint Satisfaction Problem (CSP)",id:"22-constraint-satisfaction-problem-csp",level:2}];function c(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"11-integer-linear-programming-ilp",children:"1.1 Integer Linear Programming (ILP)"}),"\n",(0,r.jsx)(e.p,{children:"Integer Linear Programming (ILP) is an optimization technique used to maximize or minimize a linear function subject to linear constraints, with decision variables restricted to integer values. It is useful for problems like resource allocation and scheduling."}),"\n",(0,r.jsxs)(e.p,{children:["In this project, the ",(0,r.jsx)(e.strong,{children:"Pulp"})," library was used to define variables, constraints, and the objective function programmatically."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Main variables:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"x[f][d][t]"}),": binary, indicates whether employee ",(0,r.jsx)(e.em,{children:"f"})," is scheduled on day ",(0,r.jsx)(e.em,{children:"d"}),", shift ",(0,r.jsx)(e.em,{children:"t"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"y[d][t][e]"}),": integer, number of employees from team ",(0,r.jsx)(e.em,{children:"e"})," on shift ",(0,r.jsx)(e.em,{children:"t"}),", day ",(0,r.jsx)(e.em,{children:"d"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"penal[d][t][e]"}),": continuous, measures the negative difference between the required minimum and actual staffing."]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective function:"}),"\nMinimize penalties related to unmet minimum shift coverage per team throughout the year."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Constraints:"}),"\nDefined to comply with rules such as workday limits, rest periods, transitions, and minimum coverage, applied individually or in groups."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Model steps:"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Data initialization."}),"\n",(0,r.jsx)(e.li,{children:"ILP model creation."}),"\n",(0,r.jsx)(e.li,{children:"Objective function definition."}),"\n",(0,r.jsxs)(e.li,{children:["Solving with ",(0,r.jsx)(e.code,{children:"PULP_CBC_CMD"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"12-hill-climbing",children:"1.2 Hill Climbing"}),"\n",(0,r.jsx)(e.p,{children:"The Hill Climbing algorithm is a local search technique that starts from a feasible initial solution and iteratively tries to improve it by minimizing penalties."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Rules followed in the initial solution:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"No work during vacation."}),"\n",(0,r.jsx)(e.li,{children:"Avoid invalid transitions (e.g., afternoon \u2192 morning)."}),"\n",(0,r.jsx)(e.li,{children:"Respect team preferences."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Penalty criteria:"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"C1: More than 5 consecutive workdays."}),"\n",(0,r.jsx)(e.li,{children:"C2: Excess weekends/holidays worked."}),"\n",(0,r.jsx)(e.li,{children:"C3: Lack of minimum shift coverage."}),"\n",(0,r.jsx)(e.li,{children:"C4: Excessive days off."}),"\n",(0,r.jsx)(e.li,{children:"C5: Invalid transitions (T\u2192M)."}),"\n",(0,r.jsx)(e.li,{children:"C6: Daily minimum coverage violations."}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Process:"}),"\nPerforms small schedule changes and keeps those that reduce the total penalty, continuing until no further improvement is possible."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"13-greedy-randomized",children:"1.3 Greedy Randomized"}),"\n",(0,r.jsx)(e.p,{children:"This algorithm builds the schedule progressively by assigning shifts to employees based on strict rules and a cost function."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Feasibility rules (f1):"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Maximum of 5 consecutive workdays."}),"\n",(0,r.jsx)(e.li,{children:"No more than 22 Sundays/holidays per employee."}),"\n",(0,r.jsx)(e.li,{children:"Prohibit invalid transitions (T\u2192M)."}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cost function (f2):"}),"\nPenalizes under-staffing, favors coverage near the ideal, and penalizes over-staffing."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Controlled randomness:"}),"\nAttempts multiple iterations (",(0,r.jsx)(e.code,{children:"num_iter"}),") per day and selects among the feasible candidates to avoid poor local optima."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"14-greedy-randomized-with-hill-climbing-refinement",children:"1.4 Greedy Randomized with Hill Climbing Refinement"}),"\n",(0,r.jsx)(e.p,{children:"A hybrid algorithm with two phases: initial construction and refinement."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Phase 1: Greedy Randomized"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Pseudo-random assignment of days and shifts respecting:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Up to 5 consecutive workdays."}),"\n",(0,r.jsx)(e.li,{children:"Maximum of 22 Sundays/holidays."}),"\n",(0,r.jsx)(e.li,{children:"No afternoon \u2192 morning transitions."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Light feasibility and cost checks."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Phase 2: Hill Climbing"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Small changes to the schedule (day swaps)."}),"\n",(0,r.jsxs)(e.li,{children:["Evaluation based on:","\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Excess consecutive workdays."}),"\n",(0,r.jsx)(e.li,{children:"Too many Sundays/holidays."}),"\n",(0,r.jsx)(e.li,{children:"Unmet minimum coverage."}),"\n",(0,r.jsx)(e.li,{children:"Deviation from ideal workload (223 days)."}),"\n",(0,r.jsx)(e.li,{children:"Invalid transitions."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Accepts changes that reduce total score."}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h1,{id:"2-algorithms-with-unsatisfactory-results",children:"2 Algorithms with Unsatisfactory Results"}),"\n",(0,r.jsx)(e.p,{children:"Some tested algorithms failed to provide satisfactory solutions for the annual schedule."}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"21-genetic-algorithm",children:"2.1 Genetic Algorithm"}),"\n",(0,r.jsxs)(e.p,{children:["Uses the ",(0,r.jsx)(e.strong,{children:"DEAP"})," library to apply evolutionary operations to schedule generation."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Individual:"})," matrix (12 x 365) with assigned shifts (0 = day off, 1 = morning, 2 = afternoon, F = vacation)."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Evaluation:"}),"\nPenalizes:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Incorrect number of workdays."}),"\n",(0,r.jsx)(e.li,{children:"Excess Sundays/holidays."}),"\n",(0,r.jsx)(e.li,{children:"Over 5 consecutive workdays."}),"\n",(0,r.jsx)(e.li,{children:"Invalid transitions (T\u2192M)."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Genetic operations:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mutation:"})," randomly swaps days."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Crossover:"})," exchanges schedule segments between individuals."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Selection:"})," tournament with elitism."]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Evolution:"})," 120 generations with CXPB = 0.7 and MUTPB = 0.3."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Result:"})," Failed to produce quality annual schedules, especially under multiple simultaneous constraints."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"22-constraint-satisfaction-problem-csp",children:"2.2 Constraint Satisfaction Problem (CSP)"}),"\n",(0,r.jsx)(e.p,{children:"Model based on constraint satisfaction, where each variable represents an employee's shift on a given day."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Variable domain:"})," morning (M_A, M_B), afternoon (T_A, T_B), off (0), vacation (F)."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Constraints:"})," implemented as functions checking the validity of assignments, including:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Vacation days."}),"\n",(0,r.jsx)(e.li,{children:"Transition rules."}),"\n",(0,r.jsx)(e.li,{children:"Max consecutive days."}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solving:"})," backtracking with constraint propagation using minimum domain heuristics."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Result:"})," Worked well for 30-day periods, but not scalable to 365 days due to execution time and complexity."]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(n){const e=s.useContext(t);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);